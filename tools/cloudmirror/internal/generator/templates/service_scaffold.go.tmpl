// Code generated by CloudMirror. DO NOT EDIT.
// Generated: {{.GeneratedAt}}
// Service: {{.ServiceName}}
// Protocol: {{.Protocol}}
// Operations: {{len .Operations}}

package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/robmorgan/infraspec-api/internal/emulator"
)

// {{.ServiceType}} implements the AWS {{.ServiceName}} service emulator
type {{.ServiceType}} struct {
	state     emulator.StateManager
	validator emulator.Validator
}

// New{{.ServiceType}} creates a new {{.ServiceName}} service instance
func New{{.ServiceType}}(state emulator.StateManager, validator emulator.Validator) *{{.ServiceType}} {
	return &{{.ServiceType}}{
		state:     state,
		validator: validator,
	}
}

// ServiceName returns the service identifier
func (s *{{.ServiceType}}) ServiceName() string {
	return "{{.ServiceNameLower}}"
}

// HandleRequest routes incoming requests to the appropriate handler
func (s *{{.ServiceType}}) HandleRequest(ctx context.Context, req *emulator.AWSRequest) (*emulator.AWSResponse, error) {
	if err := s.validator.ValidateRequest(req); err != nil {
		return s.errorResponse(400, "ValidationException", err.Error()), nil
	}

	action := s.extractAction(req)
	if action == "" {
		return s.errorResponse(400, "InvalidAction", "Missing or invalid action"), nil
	}

	params, err := s.parseParameters(req)
	if err != nil {
		return s.errorResponse(400, "InvalidParameterValue", err.Error()), nil
	}

	if err := s.validator.ValidateAction(action, params); err != nil {
		return s.errorResponse(400, "ValidationException", err.Error()), nil
	}

	switch action {
{{range .Operations}}	case "{{.Name}}":
		return s.{{.MethodName}}(ctx, params)
{{end}}	default:
		return s.errorResponse(400, "InvalidAction", fmt.Sprintf("Unknown action: %s", action)), nil
	}
}

func (s *{{.ServiceType}}) extractAction(req *emulator.AWSRequest) string {
	if req.Action != "" {
		return req.Action
	}
{{if eq .Protocol "json"}}
	// JSON protocol: extract from X-Amz-Target header
	target := req.Headers["X-Amz-Target"]
	if target != "" {
		parts := strings.Split(target, ".")
		if len(parts) >= 2 {
			return parts[len(parts)-1]
		}
	}
{{end}}
	return ""
}

func (s *{{.ServiceType}}) parseParameters(req *emulator.AWSRequest) (map[string]interface{}, error) {
	if req.Parameters != nil {
		return req.Parameters, nil
	}

	contentType := req.Headers["Content-Type"]
{{if or (eq .Protocol "query") (eq .Protocol "ec2")}}
	if strings.Contains(contentType, "application/x-www-form-urlencoded") {
		return s.parseFormData(string(req.Body))
	}
{{end}}
	if strings.Contains(contentType, "application/json") || strings.Contains(contentType, "application/x-amz-json") {
		var params map[string]interface{}
		if len(req.Body) == 0 {
			return make(map[string]interface{}), nil
		}
		if err := json.Unmarshal(req.Body, &params); err != nil {
			return nil, fmt.Errorf("failed to parse JSON body: %w", err)
		}
		return params, nil
	}

	return make(map[string]interface{}), nil
}
{{if or (eq .Protocol "query") (eq .Protocol "ec2")}}
func (s *{{.ServiceType}}) parseFormData(body string) (map[string]interface{}, error) {
	values, err := url.ParseQuery(body)
	if err != nil {
		return nil, err
	}

	params := make(map[string]interface{})
	for key, vals := range values {
		if len(vals) == 1 {
			params[key] = vals[0]
		} else {
			params[key] = vals
		}
	}

	return params, nil
}
{{end}}
// ============================================================================
// Operation Handlers
// ============================================================================
{{range .Operations}}
// {{.Name}}{{if .Documentation}} - {{.Documentation}}{{end}}
// Priority: {{.Priority}}{{if .Deprecated}}
// DEPRECATED{{end}}
func (s *{{$.ServiceType}}) {{.MethodName}}(ctx context.Context, params map[string]interface{}) (*emulator.AWSResponse, error) {
	// TODO: Implement {{.Name}}
{{range .RequiredParams}}	// Required: {{.Name}} ({{.GoType}})
{{end}}{{range .OptionalParams}}	// Optional: {{.Name}} ({{.GoType}})
{{end}}
	return s.errorResponse(501, "NotImplemented", "{{.Name}} is not yet implemented"), nil
}
{{end}}
// ============================================================================
// Response Helpers
// ============================================================================

func (s *{{.ServiceType}}) successResponse(action string, data interface{}) (*emulator.AWSResponse, error) {
{{if eq .Protocol "query"}}	return emulator.BuildQueryResponse(action, data, emulator.ResponseBuilderConfig{
		ServiceName: "{{.ServiceNameLower}}",
		Version:     "{{.APIVersion}}",
	})
{{else if eq .Protocol "ec2"}}	return emulator.BuildEC2Response(data, emulator.ResponseBuilderConfig{
		ServiceName: "{{.ServiceNameLower}}",
		Version:     "{{.APIVersion}}",
	})
{{else if eq .Protocol "json"}}	return emulator.BuildJSONResponse(200, data)
{{else if eq .Protocol "rest-xml"}}	rootElement := action + "Result"
	return emulator.BuildRESTXMLResponse(rootElement, data, "")
{{else if eq .Protocol "rest-json"}}	return emulator.BuildRESTJSONResponse(200, data)
{{else}}	// Default to Query protocol
	return emulator.BuildQueryResponse(action, data, emulator.ResponseBuilderConfig{
		ServiceName: "{{.ServiceNameLower}}",
		Version:     "{{.APIVersion}}",
	})
{{end}}}

func (s *{{.ServiceType}}) errorResponse(statusCode int, code, message string) *emulator.AWSResponse {
	return emulator.BuildErrorResponse("{{.ServiceNameLower}}", statusCode, code, message)
}

// ============================================================================
// Parameter Helpers
// ============================================================================

func getStringValue(params map[string]interface{}, key string) string {
	if val, ok := params[key].(string); ok {
		return val
	}
	return ""
}

func getInt32Value(params map[string]interface{}, key string, defaultValue int32) int32 {
	if val, ok := params[key].(float64); ok {
		return int32(val)
	}
	if val, ok := params[key].(int); ok {
		return int32(val)
	}
	if val, ok := params[key].(int32); ok {
		return val
	}
	if val, ok := params[key].(string); ok {
		var parsed int32
		if _, err := fmt.Sscanf(val, "%d", &parsed); err == nil {
			return parsed
		}
	}
	return defaultValue
}

func getBoolValue(params map[string]interface{}, key string, defaultValue bool) bool {
	if val, ok := params[key].(bool); ok {
		return val
	}
	if val, ok := params[key].(string); ok {
		return strings.ToLower(val) == "true"
	}
	return defaultValue
}
